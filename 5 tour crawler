#include <fstream>
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <cstring>
#include <thread>
#include <chrono>
#include <mutex>
#include <regex>
#include <atomic>

using namespace std;
using namespace chrono;

class crawler {
private:
    int Threads_count;
    string RepositoryDownl = "crawler\\";
    string RepositoryPushl = "crawler_output\\";
    string startPath;
    vector <thread> threads;
    queue <string> goingtoProcessed;
    set <string> processed;
    mutex contLock;
    atomic <int> TasksAllStart;
    atomic <int> TasksEnded;
    condition_variable checking;

public:
    crawler(int count, string input) : Threads_count(count), startPath(input) {
        goingtoProcessed.push(input);
    }


    void ThreadProcessFile(string file, regex& pattern) {
        ifstream in(RepositoryDownl + file);
        ofstream out(RepositoryPushl + file);
        string line;
        vector<string> hrefs;

        while (getline(in, line)) {
            smatch match;
            out << line << endl;
            while (regex_search(line, match, pattern)) {
                hrefs.push_back(move(match.str(1)));
                line = move(match.suffix().str());
            }
        }
        in.close();
        out.close();
        {
            lock_guard<mutex> lockGuard(contLock);
            for (auto& i : hrefs)
                goingtoProcessed.push(i);
            processed.insert(file);
        }
    }


    pair<bool, string> ThreadGetNewFile() {
        if (!goingtoProcessed.empty()) {
            string nextFile = goingtoProcessed.front();
            goingtoProcessed.pop();
            return make_pair(true, nextFile);
        }
        return make_pair(false, "");
    }

    void ThreadProgram(regex& pattern) {
        bool equal = false;
        do {
            unique_lock <mutex> lock(contLock);
            checking.wait(lock, [&]() { return TasksEnded.load() == TasksAllStart.load() || !goingtoProcessed.empty(); });
            equal = (TasksEnded.load() == TasksAllStart.load());
            auto file = ThreadGetNewFile();
            if (file.first) {
                if (processed.count(file.second) == 0) {
                    TasksAllStart++;
                    lock.unlock();
                    ThreadProcessFile(file.second, pattern);
                    TasksEnded++;
                    checking.notify_all();
                }
                else {
                    lock.unlock();
                }
                equal = false;
            }
        } while (!equal);
        {
            lock_guard<mutex> lockGuard(contLock);
            cout << "Id of Thread = " << this_thread::get_id() << " end!" << endl;
        }
    }

    pair<int, int> crawl() {
        cout << "Num of Threads = " << Threads_count << endl;
        processed.clear();
        TasksAllStart.store(0);
        TasksEnded.store(0);

        time_point<system_clock> start, end;
        regex pattern("<a href=\"file://([a-za-z0-9.]+html)\">");
        start = system_clock::now();
        
        for (int i = 0; i < Threads_count; ++i)
            threads.push_back(thread(&crawler::ThreadProgram, ref(*this), ref(pattern)));
        for (int i = 0; i < Threads_count; ++i) {
            threads[i].join();
        }

        end = system_clock::now();
        int time = duration_cast<microseconds>(end - start).count();
        
        return { processed.size(), time };
    }
};

int main() {
    ifstream fin("input.txt");

    string inp;

    int NumberOfThreads;
    fin >> inp >> NumberOfThreads;
    fin.close();

    crawler crawler(NumberOfThreads, inp);
    pair<int, int> result = crawler.crawl();
    ofstream fout("output.txt");

    fout << result.first << " " << result.second << " microseconds";
    fout.close();
    return 0;
}
